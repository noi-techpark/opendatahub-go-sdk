// SPDX-FileCopyrightText: 2024 NOI Techpark <digital@noi.bz.it>
//
// SPDX-License-Identifier: MPL-2.0

package rdb

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/noi-techpark/opendatahub-go-sdk/ingest/urn"
	"github.com/noi-techpark/opendatahub-go-sdk/tel"
	httptel "github.com/noi-techpark/opendatahub-go-sdk/tel/http"
	"go.opentelemetry.io/otel/trace"
)

type RawAny Raw[any]

// raw data message as generated by data collectors and stored in the mongodb
type Raw[Rawtype any] struct {
	Provider  string    `json:"provider"`
	Timestamp time.Time `json:"timestamp"`
	Rawdata   Rawtype   `json:"rawdata"`
}

var (
	ErrDocumentNotFound = errors.New("document not found")
	ErrBadURN           = errors.New("bad urn format")
	ErrServerErr        = errors.New("internal server error")
)

type Env struct {
	RAW_DATA_BRIDGE_ENDPOINT string
}

type RDBridge struct {
	endpoint string
}

func NewRDBridge(config Env) *RDBridge {
	return &RDBridge{
		endpoint: strings.TrimRight(config.RAW_DATA_BRIDGE_ENDPOINT, "/"),
	}
}

func (b RDBridge) Get(ctx context.Context, urn *urn.URN) ([]byte, error) {
	// Start a new client span for the outbound HTTP request.
	// this uses GlobalTelemetry
	ctx, clientSpan := tel.TraceStart(
		ctx,
		fmt.Sprintf("HTTP GET /urns/%s", urn.String()),
		trace.WithSpanKind(trace.SpanKindClient),
	)
	defer clientSpan.End()

	// Create a new request with the provided context (which now carries the client span).
	req, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/urns/%s", b.endpoint, urn.String()), nil)
	if err != nil {
		tel.OnError(ctx, "failed to create request", err)
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Use your HTTP client that injects trace context.
	httpClient := httptel.NewHttpTelClient()
	resp, err := httpClient.Do(req)
	if err != nil {
		tel.OnError(ctx, "failed to get raw data", err)
		return nil, fmt.Errorf("failed to get raw data: %s", err.Error())
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		return nil, ErrDocumentNotFound
	}
	if resp.StatusCode == http.StatusBadRequest {
		return nil, ErrBadURN
	}
	if resp.StatusCode != http.StatusOK {
		return nil, ErrServerErr
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		tel.OnError(ctx, "failed to read raw data body", err)
		return nil, fmt.Errorf("failed to read raw data body: %s", err.Error())
	}
	return body, nil
}

func Get[P any](rdb *RDBridge, ctx context.Context, urn *urn.URN) (Raw[P], error) {
	body, err := rdb.Get(ctx, urn)
	if err != nil {
		return Raw[P]{}, err
	}
	// First, unmarshal into a temporary structure where Rawdata is a string
	var temp Raw[string]
	err = json.Unmarshal(body, &temp)
	if err != nil {
		return Raw[P]{}, fmt.Errorf("failed to unmarshal raw data wrapper: %s", err.Error())
	}

	// Now, unmarshal Rawdata (which is a string) into the desired type P
	var payload P
	err = json.Unmarshal([]byte(temp.Rawdata), &payload)
	if err != nil {
		return Raw[P]{}, fmt.Errorf("failed to unmarshal rawdata field: %s", err.Error())
	}

	// Return properly typed Raw
	return Raw[P]{
		Provider:  temp.Provider,
		Timestamp: temp.Timestamp,
		Rawdata:   payload,
	}, nil
}
